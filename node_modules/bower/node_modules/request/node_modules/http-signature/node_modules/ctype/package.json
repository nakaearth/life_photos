{
  "name": "ctype",
  "version": "0.5.2",
  "description": "read and write binary structures and data types",
  "homepage": "https://github.com/rmustacc/node-ctype",
  "author": {
    "name": "Robert Mustacchi",
    "email": "rm@fingolfin.org"
  },
  "engines": {
    "node": ">= 0.4"
  },
  "main": "ctype.js",
  "readme": "This library provides a way to read and write binary data.\n\nNode CType is a way to read and write binary data in structured and easy to use\nformats. It's name comes from the header file, though it does not share as much\nwith it as it perhaps should.\n\nThere are two levels of the API. One is the raw API which everything is built on\ntop of, while the other provides a much nicer abstraction and is built entirely\nby using the lower level API. The hope is that the low level API is both clear\nand useful. The low level API gets it's names from stdint.h (a rather\nappropriate source). The lower level API is presented at the end of this\ndocument.\n\nStandard CType API\n\nThe CType interface is presented as a parser object that controls the\nendianness combined with a series of methods to change that value, parse and\nwrite out buffers, and a way to provide typedefs.  Standard Types\n\nThe CType parser supports the following basic types which return Numbers except\nas indicated:\n\n    * int8_t\n    * int16_t\n    * int32_t\n    * int64_t (returns an array where val[0] << 32 + val[1] would be the value)\n    * uint8_t\n    * uint16_t\n    * uint32_t\n    * uint64_t (returns an array where val[0] << 32 + val[1] would be the value)\n    * float\n    * double\n    * char (returns a buffer with just that single character)\n    * char[] (returns an object with the buffer and the number of characters read which is either the total amount requested or until the first 0)\n\nSpecifying Structs\n\nThe CType parser also supports the notion of structs. A struct is an array of\nJSON objects that defines an order of keys which have types and values. One\nwould build a struct to represent a point (x,y) as follows:\n\n[\n    { x: { type: 'int16_t' }},\n    { y: { type: 'int16_t' }}\n]\n\nWhen this is passed into the read routine, it would read the first two bytes\n(as defined by int16_t) to determine the Number to use for X, and then it would\nread the next two bytes to determine the value of Y. When read this could\nreturn something like:\n\n{\n    x: 42,\n    y: -23\n}\n\nWhen someone wants to write values, we use the same format as above, but with\nadditional value field:\n\n[\n    { x: { type: 'int16_t', value: 42 }},\n    { y: { type: 'int16_t', value: -23 }}\n]\n\nNow, the structure above may be optionally annotated with offsets. This tells\nus to rather than read continuously we should read the given value at the\nspecified offset. If an offset is provided, it is is effectively the equivalent\nof lseek(offset, SEEK_SET). Thus, subsequent values will be read from that\noffset and incremented by the appropriate value. As an example:\n\n[\n    { x: { type: 'int16_t' }},\n    { y: { type: 'int16_t', offset: 20 }},\n    { z: { type: 'int16_t' }}\n]\n\nWe would read x from the first starting offset given to us, for the sake of\nexample, let's assume that's 0. After reading x, the next offset to read from\nwould be 2; however, y specifies an offset, thus we jump directly to that\noffset and read y from byte 20. We would then read z from byte 22.\n\nThe same offsets may be used when writing values.\n\nTypedef\n\nThe basic set of types while covers the basics, is somewhat limiting. To make\nthis richer, there is functionality to typedef something like in C. One can use\ntypedef to add a new name to an existing type or to define a name to refer to a\nstruct. Thus the following are all examples of a typedef:\n\ntypedef('size_t', 'uint32_t');\ntypedef('ssize_t', 'int32_t');\ntypedef('point_t', [\n    { x: { type: 'int16_t' }},\n    { y: { type: 'int16_t' }}\n]);\n\nOnce something has been typedef'd it can be used in any of the definitions\npreviously shown.\n\nOne cannot remove a typedef once created, this is analogous to C.\n\nThe set of defined types can be printed with lstypes. The format of this output\nis subject to change, but likely will look something like:\n\n> lstypes();\n{\n    size_t: 'uint32_t',\n    ssize_t: 'int32_t',\n    point_t: [\n        { x: { type: 'int16_t' }},\n        { y: { type: 'int16_t' }}\n    ]\n}\n\nSpecifying arrays\n\nArrays can be specified by appending []s to a type. Arrays must have the size\nspecified. The size must be specified and it can be done in one of two ways:\n\n    * An explicit non-zero integer size\n    * A name of a previously declared variable in the struct whose value is a\n      number.\n\nNote, that when using the name of a variable, it should be the string name for\nthe key. This is only valid inside structs and the value must be declared\nbefore the value with the array. The following are examples:\n\n[\n    { ip_addr4: { type: 'uint8_t[4]' }},\n    { len: { type: 'uint32_t' }},\n    { data: { type: 'uint8_t[len]' }}\n]\n\nArrays are permitted in typedefs; however, they must have a declared integer\nsize. The following are examples of valid and invalid arrays:\n\ntypedef('path', 'char[1024]'); /* Good */\ntypedef('path', 'char[len]');  /* Bad! */\n\n64 bit values:\n\nUnfortunately Javascript represents values with a double, so you lose precision\nand the ability to represent Integers roughly beyond 2^53. To alleviate this, I\npropose the following for returning 64 bit integers when read:\n\nvalue[2]: Each entry is a 32 bit number which can be reconstructed to the\noriginal by the following formula:\n\nvalue[0] << 32 + value[1] (Note this will not work in Javascript)\n\nCTF JSON data:\n\nnode-ctype can also handle JSON data that mathces the format described in the\ndocumentation of the tool ctf2json. Given the JSON data which specifies type\ninformation, it will transform that into a parser that understands all of the\ntypes defined inside of it. This is useful for more complicated structures that\nhave a lot of typedefs.\n\nInterface overview\n\nThe following is the header-file like interface to the parser object:\n\n/*\n * Create a new instance of the parser. Each parser has its own store of\n * typedefs and endianness. Conf is an object with the following values:\n *\n *      endian          Either 'big' or 'little' do determine the endianness we\n *                      want to read from or write to.\n *\n */\nfunction CTypeParser(conf);\n\n/*\n * Parses the CTF JSON data and creates a parser that understands all of those\n * types.\n *\n *\tdata\t\tParsed JSON data that maches that CTF JSON\n *\t\t\tspecification.\n *\n *\tconf\t\tThe configuration object to create a new CTypeParser\n *\t\t\tfrom.\n */\nCTypeParser parseCTF(data, conf);\n\n/*\n * This is what we were born to do. We read the data from a buffer and return it\n * in an object whose keys match the values from the object.\n *\n *      def             The array definition of the data to read in\n *\n *      buffer          The buffer to read data from\n *\n *      offset          The offset to start writing to\n *\n * Returns an object where each key corresponds to an entry in def and the value\n * is the read value.\n */\nObject CTypeParser.readData(<Type Definition>, buffer, offset);\n\n/*\n * This is the second half of what we were born to do, write out the data\n * itself.\n *\n *      def             The array definition of the data to write out with\n *                      values\n *\n *      buffer          The buffer to write to\n *\n *      offset          The offset in the buffer to write to\n */\nvoid CTypeParser.writeData(<Type Definition>, buffer, offset);\n\n/*\n * A user has requested to add a type, let us honor their request. Yet, if their\n * request doth spurn us, send them unto the Hells which Dante describes.\n *\n *      name            The string for the type definition we're adding\n *\n *      value           Either a string that is a type/array name or an object\n *                      that describes a struct.\n */\nvoid CTypeParser.prototype.typedef(name, value);\n\nObject CTypeParser.prototype.lstypes();\n\n/*\n * Get the endian value for the current parser\n */\nString CTypeParser.prototype.getEndian();\n\n/*\n * Sets the current endian value for the Parser. If the value is not valid,\n * throws an Error.\n *\n *      endian          Either 'big' or 'little' do determine the endianness we\n *                      want to read from or write to.\n *\n */\nvoid CTypeParser.protoype.setEndian(String);\n\n/*\n * Attempts to convert an array of two integers returned from rsint64 / ruint64\n * into an absolute 64 bit number. If however the value would exceed 2^52 this\n * will instead throw an error. The mantissa in a double is a 52 bit number and\n * rather than potentially give you a value that is an approximation this will\n * error. If you would rather an approximation, please see toApprox64.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nNumber function toAbs64(val)\n\n/*\n * Will return the 64 bit value as returned in an array from rsint64 / ruint64\n * to a value as close as it can. Note that Javascript stores all numbers as a\n * double and the mantissa only has 52 bits. Thus this version may approximate\n * the value.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nNumber function toApprox64(val)\n\nLow Level API\n\nThe following function are provided at the low level:\n\nRead unsigned integers from a buffer:\nNumber ruint8(buffer, endian, offset);\nNumber ruint16(buffer, endian, offset);\nNumber ruint32(buffer, endian, offset);\nNumber[] ruint64(buffer, endian, offset);\n\nRead signed integers from a buffer:\nNumber rsint8(buffer, endian, offset);\nNumber rsint16(buffer, endian, offset);\nNumber rsint32(buffer, endian, offset);\nNumber[] rsint64(buffer, endian, offset);\n\nRead floating point numbers from a buffer:\nNumber rfloat(buffer, endian, offset);   /* IEEE-754 Single precision */\nNumber rdouble(buffer, endian, offset);  /* IEEE-754 Double precision */\n\nWrite unsigned integers to a buffer:\nvoid wuint8(Number, endian, buffer, offset);\nvoid wuint16(Number, endian, buffer, offset);\nvoid wuint32(Number, endian, buffer, offset);\nvoid wuint64(Number[], endian, buffer, offset);\n\nWrite signed integers from a buffer:\nvoid wsint8(Number, endian, buffer, offset);\nvoid wsint16(Number, endian, buffer, offset);\nvoid wsint32(Number, endian, buffer, offset);\nvoid wsint64(Number[], endian, buffer offset);\n\nWrite floating point numbers from a buffer:\nvoid wfloat(Number, buffer, endian, offset);   /* IEEE-754 Single precision */\nvoid wdouble(Number, buffer, endian, offset);  /* IEEE-754 Double precision */\n\n",
  "readmeFilename": "README.old",
  "_id": "ctype@0.5.2",
  "_from": "ctype@0.5.2"
}
